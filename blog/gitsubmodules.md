Зачем нужны субмодули ? Ну если совсем просто, то субмодуль - это репозиторий
внутри другого репозитория, вернее даже не сам репозиторий, а хеш коммита
субрепозитория и адрес откуда его можно скачать.

Пример: у вас есть проект, допустим это сайт, и есть некоторые, скажем, плагины
к проекту. Каждый плагин - отдельный проект, который был начат не вами, либо
используется в нескольких ваших проектах. Понятно, что плагины для сайта лучше
не держать в подкаталогах репозитория основного проекта - ведь тогда вы лешитесь
возможности отдельной независимой разработки каждого плагина и сломаете историю
исходного проекта (если таковой был) а значит не сможете вернуть ваши наработки
в апстрим.

Кроме того, часто бывает, что ваш основной проект имеет сильную связанность с
плагинами: плагины "дотачиваются" под нужды основного проекта и наоборот -
проект сделан с расчетом на некоторые "особенности" плагинов. К тому же,
появляется желание автоматизировать процесс установки / удаления плагинов из
вашего основного проекта, ведь проект развивается и со временем становится
трудно следить где какой плагин установлен и какая версия плагина используется в
проекте сейчас.

Тут мы и подошли к сути субмодулей. Когда вы добавляете субмодуль в репозиторий,
то в вашем репозитории сохраняется адрес субмодуля и идентификатор коммита,
являющегося на данный момент актуальным. В процессе разработки в плагин
добавляются новые коммиты, которые комитсятся в репозиторий плагина, отдельно и
независимо, а новый идентификатор коммита субмодуля записывается в коммит
основного проекта. Таким образом основной проект помнит в какой версии основного
проекта какая версия плагина должна использоваться.

Сферический пример в вакууме:

```
cd path_to_plugin
..... фиксим багу в плагине
git commit -m 'fixed :)'
git push        # сохраняем изменения в репозиторий плагина
cd path_to_project
cd path_of_submodule_in_project
git pull        # получили новую версию плагина в репозиторий проекта
cd path_to_project
git add path_of_submodule_in_project
git commit -m 'commited info about changes in submodule'
git push
```

теперь на тестовой системе накатываем изменения разработчика

```
git pull
git submodule update --init # а вот тут мы делаем обновление субмодулей в
                            # рабочем каталоге, checkout нужной версии
                            # плагина происходит автоматически
```

# Шероховатости

Не все так круто, к сожалению. Не знаю почему в git субмодули сделаны так
странно. Может потому, что раньше их не было и решили добавить так, чтобы не
ломать обратную совместимость с более старыми версиями репозиториев, может еще
почему.

Git держит информацию о субмодулях в целых 3х местах:

1. .gitmodules - файл в корне репозитория со списком субмодулей и адресами
репозиториев для каждого субмодуля. Именно в этом файле лежит изначальный список
субмодулей, используемых в вашем репозитории. Этот файл обязатльно должен быть
добавлен в контроль версий.
2. .git/config - общий файл конфигурации для git в нем лежит список веток, их
настроек и список субмодулей, этот список дублирует .gitmodules, но config
используется для работы, а .gitmodules только для хранения и контроля версий.
3. Коммиты. Когда текущий коммит (HEAD) субмодуля изменяется, то git status
в основном проекте показывает это как "new commits", это значит, что HEAD в
субмодуле не совпадает с HEAD записанном в индеске основного проекта. Коммиты
основного рпеозитория - это единственное место, где хранится текущий HEAD
каждого субмодуля.

Изза того, что .gitmodules продублированы в .git/config возникают некоторые
странности при работе с субмодулями, например при удалении субмодуля или попытке
изменить URL репозитория субмодуля.

# init и sync

Две команды которые будут решать ваши проблемы с субмодулями это

```
git submodule init
git submodule sync
```

Первая помещает в .git/config недостающие записи из .gitmodules. Можно
использовать ее для добавления новых субмодулей, а можно для удаления субмодулей
или обновления урлов субмодулей. Если в .git/config просто удалить все записи о
субмодулях а потом восстановить их с помощью ```git submodule init```, то конфигурация
из .gitmodules перекочует в .git/config в првильном виде (не стоит копировать ее
вручную).

Таким способом можно удалять субмодули, менять их урлы или просто приводить файл
конфигурации в порядок. Нужно отметить, что .git/config не попадает под контроль
версий, и его обновление нужно только для того, чтобы локальный репозиторий
начал работать с новой конфигурацией субмодулей, которая хранится и
отслеживается в .gitmodules. За актуальностью .git/config нужно следить вручную.

```git submodule sync``` приводит имеющиеся в .git/config записи к соответствию с
.gitmodules. С помощью нее можно удобно менять урлы субмодулей (если адрес
репозитория плагина переехал и нужно это отобразить в вашем локальном
репозитории) просто поменяв их в .gitmodules и выполнив ```git submodule sync```.

В git нету команды, которая удаляла бы из .git/config записи, которых нет в
.gitmodules, по этому при удалении субмодулей их нужно удалять с помощью
текстового редактора.

Удаление субмодуля:

1. Удаляем каталог субмодуля с помощью git rm
2. Проверяем, что в .gitmodules пропала запись о субмодуле, либо удаляем ее
вручную
3. Коммитим
4. Актуализируем содержимое .git/config любым удобным способом.

Изменение URL субмодуля:

1. Меняем URL в .gitmodules
2. Коммитим
3. git submodule sync
4. Если версия git старше 1.7.9, то в каталоге с субмодулем наверняка вместо
каталога .git присутствует текстовый файл .git, в котором записан путь до
репозитория в .git основого проекта. Это новый способ git работы с субмодулями и
возможно у вас будут с ним проблемы (как были у меня). В это случае вам придется
перейти в каталог с субмодулем и изменить адрес удаленного репозитория с помощью
```
git config remote.origin.url [новый URL]
```

Повторюсь еще раз: начиная с третьего пункта производятся действия, необходимые
только для того, чтобы локальный репозиторий начал правильно работать с
обновленной информацией о субмодулях, грубо говоря - актуализация локальной
настройки репозитория. Кстати, те же действия нужно выполнять после ```git
pull``` с которым приходят коммиты, меняющие .gitmodules.

Более подробное описание вариантов использования субмодулей есть в
[книге по git](http://git-scm.com/book/ru/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D0%BE%D0%B4%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8)
