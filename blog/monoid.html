<p>
  Что такое моноид ? Ну, если говорить простым языком, моноид - это множество
элементов, которые могут соединяться друг с другом и в результате получаются
новые элементы того же множества.
</p>
<p>
  Если говорить более формально, моноид - это множество с определенной над его
элементами операцией композиции и нулем - элементом этого же множества
нейтральным к операции композиции. Операция композиции при этом должна быть
ассоциативна ( (a + b) + c = a + (b + c) ).
</p>
<p>
  Примером моноида могут служить все натуральные числа, операция сложения в
качестве операции композиции, и число 0 в качестве нейтрального элемента. Стоит
,так же, заметить, что коммутативность сложения (2 + 3 = 3 + 2) не является
обязательной для моноида. В общем случае операция композиции в моноиде не
коммутативна. Например, множество всех строк с операцией конкатенации строк в
качестве операции композиции и пустая строка в качестве нейтрального элемента -
тоже моноид, однако "abc" + "def" != "def" + "abc"
</p>
<p> 
  Конечность или бесконечность множества тоже не важна для моноида. Это значит,
что если множество конечно, то все его элементы можно конкатенировать друг с
другом в один элемент. При этом, какой именно это будет элемент может зависеть
от порядка конкатенации - в случае если операция конкатенации не коммутативна.
</p>
<p>
  Ассоциативность композиции придает моноиду интересные свойтва: мы можем взять
  список элементов моноида и соединить их в один элемент, при чем как именно нам
  не важно.<br />
  Можем так:
  <pre>
    [a, b, c, d] ->
    [ab, cd] ->
    [abcd]
  </pre>
  А можем и так:
  <pre>
    [a, b, c, d] ->
    [a, bc, d] ->
    [a, bcd] ->
    [abcd]
  </pre>
  Результат всегда будет один и тот же. Это свойство позволяет абстрагировать
  моноидами самые различные области реального программирования.
</p>

<h1>Моноид Sum</h1>
<p>
  Раз уж мы заговорили про натуральные числа, как моноид, то давайте посмотрим
  на реализацию моноида Sum из прелюдии GHC.
  <pre>
    newtype Sum a = Sum { getSum :: a }
        deriving (Eq, Ord, Read, Show, Bounded)

    instance Num a => Monoid (Sum a) where
        mempty = Sum 0
        Sum x `mappend` Sum y = Sum (x + y)
  </pre>
</p>
<p>
  Это моноид не над натуральными числами, но над числами вообще, вернее
  экземплярами тайпкласса Num, в котором определена операция (+). Sum - это
  оберточный тип для одного элемента, который можно вытащить функцией
  getSum. вот как можно пользоваться этим моноидом:
  <pre>
    getSum $ mconcat $ map Sum ([1..100] :: [Double])
  </pre>
  Данная функция вернет 5050
</p>
<p>
  Что это было ? Ну сначала мы создаем список чисел от 1 до 100, затем каждое
  число оборачивается оберточным типом Sum и получается [Sum Double]. Затем
  моноиды в списке конкатенируются и получается Sum Double из котороко мы
  вытаскиваем результат с помощью getSum.
</p>
<p>
  Проще говоря мы складываем все элементы списка. Что тут такого ? Конкретно тут
  ничего. Мы можем складывать элементы списка и без моноида, более того, мы
  можем складывать результаты сложения элементов свписков и получать сумму всех
  элементов всех списков
</p>
<pre>
  sum $ map (sum) $ [[1,2,3], [4,5], [6]]
</pre>
<p>
  результат - 21, такой же как у
</p>
<pre>
  sum [1..6]
</pre>
<p>
  Это значит, что результат суммирования всех элементов обладает важным
свойством: над ним можно проводить сложение или композицю. Вот почему Sum -
моноид.
</p>
<h1>Моноид First</h1>
<p>
  Смотрим определение в прелюдии
</p>
<pre>
newtype First a = First { getFirst :: Maybe a }
        deriving (Eq, Ord, Read, Show)

instance Monoid (First a) where
        mempty = First Nothing
        r@(First (Just _)) `mappend` _ = r
        First Nothing `mappend` r = r
</pre>



<p>
  Однако не всегда можно обойтись без явного моноида, далее об этом.
</p>
