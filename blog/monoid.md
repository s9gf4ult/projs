Если говорить более формально, моноид - это множество с определенной над его
элементами операцией композиции и нулем - элементом этого же множества
нейтральным к операции композиции. Операция композиции при этом должна быть
ассоциативна ( (a + b) + c = a + (b + c) ).

Примером моноида могут служить все натуральные числа, операция сложения в
качестве операции композиции, и число 0 в качестве нейтрального элемента. Стоит
,так же, заметить, что коммутативность сложения (2 + 3 = 3 + 2) не является
обязательной для моноида. В общем случае операция композиции в моноиде не
коммутативна. Например, множество всех строк с операцией конкатенации строк в
качестве операции композиции и пустая строка в качестве нейтрального элемента -
тоже моноид, однако "abc" + "def" != "def" + "abc"

Конечность или бесконечность множества тоже не важна для моноида. Это значит,
что если множество конечно, то все его элементы можно конкатенировать друг с
другом в один элемент. При этом, какой именно это будет элемент может зависеть
от порядка конкатенации - в случае если операция конкатенации не коммутативна.

Ассоциативность композиции придает моноиду интересные свойтва: мы можем взять
список элементов моноида и соединить их в один элемент, при чем как именно нам
не важно.

Можем так:

    [a, b, c, d] ->
    [ab, cd] ->
    [abcd]

А можем и так:

    [a, b, c, d] ->
    [a, bc, d] ->
    [a, bcd] ->
    [abcd]

Результат всегда будет один и тот же. Это свойство позволяет абстрагировать
моноидами самые различные области реального программирования.

# Моноид Sum

Раз уж мы заговорили про натуральные числа, как моноид, то давайте посмотрим
на реализацию моноида Sum из прелюдии GHC.

```haskell
newtype Sum a = Sum { getSum :: a }
    deriving (Eq, Ord, Read, Show, Bounded)

instance Num a => Monoid (Sum a) where
    mempty = Sum 0
    Sum x `mappend` Sum y = Sum (x + y)
```

Это моноид не над натуральными числами, но над числами вообще, вернее
экземплярами тайпкласса Num, в котором определена операция (+). Sum - это
оберточный тип для одного элемента, который можно вытащить функцией
getSum. вот как можно пользоваться этим моноидом:

```haskell
getSum $ mconcat $ map Sum ([1..100] :: [Double])
```
Данное выражение вернет 5050

Что это было ? Ну сначала мы создаем список чисел от 1 до 100, затем каждое
число оборачивается оберточным типом Sum и получается [Sum Double]. Затем
моноиды в списке конкатенируются и получается Sum Double из котороко мы
вытаскиваем результат с помощью getSum.

```haskell
sum $ map (sum) $ [[1,2,3], [4,5], [6]]
```

результат 21, такой же как у

```haskell
    sum [1..6]
```

Это значит, что результат суммирования всех элементов обладает важным
свойством: над ним можно проводить сложение или композицю. Вот почему Sum -
моноид.

# Моноид First

Смотрим определение в прелюдии

```haskell
newtype First a = First { getFirst :: Maybe a }
        deriving (Eq, Ord, Read, Show)

instance Monoid (First a) where
        mempty = First Nothing
        r@(First (Just _)) `mappend` _ = r
        First Nothing `mappend` r = r
```

Ну тут все почти тоже самое. Определение mappend показывает, что он вернет
первый аргемет, если там (First (Just _)). То есть любое не пустое значение. И
вернет второй аргумент если в первом аргументе (First Nothing). Список элементов
этого моноида редуцируется до первого встреченного в списке не пустого значения.

Этот моноид похож на Sum тем, что результ редукции списка элементов можно
объединить с другим результатом редцкии списка элементов и получить результат
редукции конкатенированных изначальных списков

```
[Nothing, Just 10, Nothing, Just 1] -> Just 10
[Nothing, Nothing, Just 2] -> Just 2
[Just 10, Just 2] -> Just 10
```

Это тоже самое что и

```
[Nothing, Just 10, Nothing, Just 1, Nothing, Nothing, Just 2] -> Just 10
```

и в этом случае тоже можно (но не нужно) обходиться без моноида, но не все
моноиды такие простые.

# Моноид Avg

Этого моноида нет в прелюдии, в библиотеках я его тоже не нашел.

Вернемся к числам. Предположим, мы хотим вычислять среднее значение элементов
списка. Это легко делается с помощью такой функции

```haskell
avg :: (Fractional a) => [a] -> Maybe a
avg [] = Nothing
avg x = Just ((sum x) / (fromIntegral $ length x))
```

Сумму всех элементов делим на их количество. Обратите внимание, что возвращаем
не число, а Maybe число, так как среднее значение пустого списка не имеет
смысла, а мы пишем безопасную type-safe программу.

Посмотрим, что функция будет выдавать на разных входных данных:

```
*Main> avg [1..10]
Just 5.5
*Main> avg [5..9]
Just 7.0
*Main> avg [4]
Just 4.0
*Main> avg []
Nothing
```

Вроде все просто. А теперь попробуем посчитать среднее значение от
конкатенированного списка:

```
*Main> avg $ concat [[1..10], [5..9]]
Just 6.0
```

и среднее значение от средних значений отдельных результатов:

```
*Main> avg [5.5, 7]
Just 6.25
```

Естественно ничего не получается, ведь нельзя считать среднее значение путем
усреднения средних значений. И, в тоже время мы не хотим тянуть в наше
вычисление весь список чисел, чтобы конкатенировать, а потом посчитать среднее
от результата. Мы хотим иметь такие магические объекты, из которых можно
вынимать средние значения, и в тоже время их можно усреднять друг с другом и все
равно получать среднее значение всех элементов, на основе которых построен этот
объект. Такой объект - и есть моноид.

Для начала само определение и инстанс:

```haskell
data Avg a = Avg {aSum :: a,
                  aCount :: Int}
             deriving (Eq, Show)

instance (Num a) => Monoid (Avg a) where
  mempty = Avg 0 0
  mappend (Avg v c) (Avg vv cc) = Avg (v + vv) (c + cc)
```

Как то подозрительно просто ...

Наша структура состоит из двух полей: поле суммы элементов и поле количества
элементов. Очевидно, что если мы знаем сумму и количество элементов двух
списков, то сложив их мы получим сумму и количество элементов обоих списков. Вот
почему операция копозиции mappend определена именно так.

Напишем еще пару вспомогательных функций:

```haskell
mkAvg a = Avg a 1

getAvg (Avg v 0) = Nothing
getAvg (Avg v c) = Just $ v / (fromIntegral c)
```

mkAvg создает для нас Avg из одного элемента, логично, что количество элементов
равно 1.

getAvg выполняет то, зачем этот моноид написан - вычисляет среднее. Отметьте,
что возвращаемое значение тоже имеет тип (Maybe a), ибо на ноль делить нельзя, а
наша программа исключений выкидывать не должна. Вот таким неявным образом мы
пришли к одному и тому же алгоритму.

Давайте посмотрим как это работает:

```
*Main> getAvg $ mconcat $ map mkAvg [1..10]
Just 5.5
*Main> getAvg $ mconcat $ map mkAvg [5..9]
Just 7.0
*Main> getAvg $ mconcat $ map mkAvg $ concat [[1..10], [5..9]]
Just 6.0
*Main> getAvg $ mconcat $ map mconcat $ map (map mkAvg) [[1..10], [5..9]]
Just 6.0
```

Первые две строки нужны для проверки того, что мы получаем такие же результаты
как и в случае с avg, а вот вторые две интереснее.

В строке 3 мы просто конкатенируем наши списки получая список чисел и
вычисляя среднее значение как обычно, а вот втрока 4 вычисляется совсем иначе:
сначала каждый элемент субэлемент списка оборачивается моноидом, проще говоря,
просиходит такое отображение [[Double]] -> [[Avg Double]]. Далее, каждый
вложенный список мы редуцируем до одного элемента, то есть так [[Avg Double]] ->
[Avg Double]. Ну и в конце просто редуцируем список до одного элемента с помощью
mconcat.

Результат одинаков, не смотря на то, что работаем с моноидами в последних двух
строках совершенно по разному.

Еще немного опытов

```haskell
avg3 x y = do
  let xag = mconcat $ map mkAvg x
      yag = mconcat $ map mkAvg y
  xa <- getAvg xag
  ya <- getAvg yag
  ra <- getAvg $ mappend xag yag -- результат композиции моноидов
  r <- avg $ concat [x, y]       -- очевидный способ
  let wrong = (xa + ya) / 2      -- не првильный способ
  return $ (r, ra, wrong)
```

```
*Main> avg3 [1..10] [2..4]
Just (4.923076923076923,4.923076923076923,4.25)
*Main> avg3 [1,3,4] [8,4]
Just (4.0,4.0,4.333333333333333)
*Main> avg3 [1,3,4] [1,3,4]
Just (2.6666666666666665,2.6666666666666665,2.6666666666666665)
```

Отклоняясь от темы напишем тест для проверки корректности

```haskell
checkEqual :: [[Rational]] -> Bool
checkEqual arb = case res of
  Nothing -> True
  Just (a, b) -> a == b
  where
    res = do
      a <- avg $ concat arb
      b <- getAvg $ mconcat $ map mconcat $ map (map mkAvg) arb
      return (a, b)

main = quickCheck checkEqual
```

Тестовые данные для нас сгенерирует QuickCheck. Он бережно переберет множество
различных вариантов, в том числе пустой список и список с пустыми списками и так
далее. Rational выбран по причине потери точности у Double при арифметиеских
операциях, из за чего тесты фейлятся. Можно, конечно, использовать неточное
сравнение, но настоящий перфекционист выбирает Rational для тестов.

Естественно, это был простейший случай моноида. В моноидах можно реализовать
множество различных алгоритмов, при этом моноиды будут еще и эффективны
благодаря ленивым вычислениям Haskell. Тот же моноид First будет вычислять
элементы только до тех пор, пока слева от композиции стоит Nothing, как только
функция композиции находит (Just _) она забывает правый и возвращает левый
элемент. Для First нет абсолютно никакой разницы между нахождением первого
ненулевого элемента в списке и сложным многослоынйм процессом композиции
моноидов.

К слову, кроме First есть еще Last. Делает тоже самое, но наоборот - находит
последний непустой элемент. Это все, что я хотел сказать про моноиды. Можете
попробовать реализовать моноид для вычисления моды по аналогии с Avg.
