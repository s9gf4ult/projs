
Что такое моноид ? Ну, если говорить простым языком, моноид - это множество
элементов, которые могут соединяться друг с другом и в результате получаются
новые элементы того же множества.

Если говорить более формально, моноид - это множество с определенной над его
элементами операцией композиции и нулем - элементом этого же множества
нейтральным к операции композиции. Операция композиции при этом должна быть
ассоциативна ( (a + b) + c = a + (b + c) ).

Примером моноида могут служить все натуральные числа, операция сложения в
качестве операции композиции, и число 0 в качестве нейтрального элемента. Стоит
,так же, заметить, что коммутативность сложения (2 + 3 = 3 + 2) не является
обязательной для моноида. В общем случае операция композиции в моноиде не
коммутативна. Например, множество всех строк с операцией конкатенации строк в
качестве операции композиции и пустая строка в качестве нейтрального элемента -
тоже моноид, однако "abc" + "def" != "def" + "abc"

Конечность или бесконечность множества тоже не важна для моноида. Это значит,
что если множество конечно, то все его элементы можно конкатенировать друг с
другом в один элемент. При этом, какой именно это будет элемент может зависеть
от порядка конкатенации - в случае если операция конкатенации не коммутативна.

Ассоциативность композиции придает моноиду интересные свойтва: мы можем взять
список элементов моноида и соединить их в один элемент, при чем как именно нам
не важно.

Можем так:

    [a, b, c, d] ->
    [ab, cd] ->
    [abcd]

А можем и так:

    [a, b, c, d] ->
    [a, bc, d] ->
    [a, bcd] ->
    [abcd]

Результат всегда будет один и тот же. Это свойство позволяет абстрагировать
моноидами самые различные области реального программирования.

# Моноид Sum

Раз уж мы заговорили про натуральные числа, как моноид, то давайте посмотрим
на реализацию моноида Sum из прелюдии GHC.

    newtype Sum a = Sum { getSum :: a }
        deriving (Eq, Ord, Read, Show, Bounded)

    instance Num a => Monoid (Sum a) where
        mempty = Sum 0
        Sum x `mappend` Sum y = Sum (x + y)
   
Это моноид не над натуральными числами, но над числами вообще, вернее
экземплярами тайпкласса Num, в котором определена операция (+). Sum - это
оберточный тип для одного элемента, который можно вытащить функцией
getSum. вот как можно пользоваться этим моноидом:

    getSum $ mconcat $ map Sum ([1..100] :: [Double])

Данное выражение вернет 5050

Что это было ? Ну сначала мы создаем список чисел от 1 до 100, затем каждое
число оборачивается оберточным типом Sum и получается [Sum Double]. Затем
моноиды в списке конкатенируются и получается Sum Double из котороко мы
вытаскиваем результат с помощью getSum.

    sum $ map (sum) $ [[1,2,3], [4,5], [6]]
    
результат 21, такой же как у

    sum [1..6]

Это значит, что результат суммирования всех элементов обладает важным
свойством: над ним можно проводить сложение или композицю. Вот почему Sum -
моноид.

# Моноид First

Смотрим определение в прелюдии

```Haskell
newtype First a = First { getFirst :: Maybe a }
        deriving (Eq, Ord, Read, Show)

instance Monoid (First a) where
        mempty = First Nothing
        r@(First (Just _)) `mappend` _ = r
        First Nothing `mappend` r = r
```            

