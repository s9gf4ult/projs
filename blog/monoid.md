
Что такое моноид ? Ну, если говорить простым языком, моноид - это множество
элементов, которые могут соединяться друг с другом и в результате получаются
новые элементы того же множества.

Если говорить более формально, моноид - это множество с определенной над его
элементами операцией композиции и нулем - элементом этого же множества
нейтральным к операции композиции. Операция композиции при этом должна быть
ассоциативна ( (a + b) + c = a + (b + c) ).

Примером моноида могут служить все натуральные числа, операция сложения в
качестве операции композиции, и число 0 в качестве нейтрального элемента. Стоит
,так же, заметить, что коммутативность сложения (2 + 3 = 3 + 2) не является
обязательной для моноида. В общем случае операция композиции в моноиде не
коммутативна. Например, множество всех строк с операцией конкатенации строк в
качестве операции композиции и пустая строка в качестве нейтрального элемента -
тоже моноид, однако "abc" + "def" != "def" + "abc"

Конечность или бесконечность множества тоже не важна для моноида. Это значит,
что если множество конечно, то все его элементы можно конкатенировать друг с
другом в один элемент. При этом, какой именно это будет элемент может зависеть
от порядка конкатенации - в случае если операция конкатенации не коммутативна.

Ассоциативность композиции придает моноиду интересные свойтва: мы можем взять
список элементов моноида и соединить их в один элемент, при чем как именно нам
не важно.

Можем так:

    [a, b, c, d] ->
    [ab, cd] ->
    [abcd]

А можем и так:

    [a, b, c, d] ->
    [a, bc, d] ->
    [a, bcd] ->
    [abcd]

Результат всегда будет один и тот же. Это свойство позволяет абстрагировать
моноидами самые различные области реального программирования.

# Моноид Sum

Раз уж мы заговорили про натуральные числа, как моноид, то давайте посмотрим
на реализацию моноида Sum из прелюдии GHC.

    newtype Sum a = Sum { getSum :: a }
        deriving (Eq, Ord, Read, Show, Bounded)

    instance Num a => Monoid (Sum a) where
        mempty = Sum 0
        Sum x `mappend` Sum y = Sum (x + y)
   
Это моноид не над натуральными числами, но над числами вообще, вернее
экземплярами тайпкласса Num, в котором определена операция (+). Sum - это
оберточный тип для одного элемента, который можно вытащить функцией
getSum. вот как можно пользоваться этим моноидом:

    getSum $ mconcat $ map Sum ([1..100] :: [Double])

Данное выражение вернет 5050

Что это было ? Ну сначала мы создаем список чисел от 1 до 100, затем каждое
число оборачивается оберточным типом Sum и получается [Sum Double]. Затем
моноиды в списке конкатенируются и получается Sum Double из котороко мы
вытаскиваем результат с помощью getSum.

    sum $ map (sum) $ [[1,2,3], [4,5], [6]]
    
результат 21, такой же как у

    sum [1..6]

Это значит, что результат суммирования всех элементов обладает важным
свойством: над ним можно проводить сложение или композицю. Вот почему Sum -
моноид.

# Моноид First

Смотрим определение в прелюдии

```haskell
newtype First a = First { getFirst :: Maybe a }
        deriving (Eq, Ord, Read, Show)

instance Monoid (First a) where
        mempty = First Nothing
        r@(First (Just _)) `mappend` _ = r
        First Nothing `mappend` r = r
```            

Ну тут все почти тоже самое. Определение mappend показывает, что он вернет
первый аргемет, если там (First (Just _)). То есть любое не пустое значение. И
вернет второй аргумент если в первом аргументе (First Nothing). Список элементов
этого моноида редуцируется до первого встреченного в списке не пустого значения.

Этот моноид похож на Sum тем, что результ редукции списка элементов можно
объединить с другим результатом редцкии списка элементов и получить результат
редукции конкатенированных изначальных списков

```
[Nothing, Just 10, Nothing, Just 1] -> Just 10
[Nothing, Nothing, Just 2] -> Just 2
[Just 10, Just 2] -> Just 10
```

Это тоже самое что и

```
[Nothing, Just 10, Nothing, Just 1, Nothing, Nothing, Just 2] -> Just 10
```

и в этом случае тоже можно обходиться без моноида, но не все моноиды такие
простые.

# Моноид Avg

Этого моноида нет в прелюдии, в библиотеках я его тоже не нашел.

Вернемся к числам. Предположим, мы хотим вычислять среднее значение элементов
списка. Это легко делается с помощью такой функции

```haskell
avg :: (Fractional a) => [a] -> Maybe a
avg [] = Nothing
avg x = Just ((sum x) / (fromIntegral $ length x))
```
