

* Было
** hdbc-sqlite3
*** Модули
**** HDBC.Sqlite3.Connection
***** Что делает
      - Создает соединение
      - Интроспекция таблиц
      - commit/rollback
***** Недостатки
      - Смешивание C и Haskell
**** HDBC.Sqlite3.Consts
***** Что делает
      - Набор констант с кодами состояния Sqlite объектов
**** HDBC.Sqlite3.Statement
***** Что делает
      - Создает новый Statement
      - Выполняет запрос
      - Запрашивает результаты
**** HDBC.Sqlite3.Utils
***** Что делает
      - Функции на подобие withConn, withStmt
** hdbc-postgresql
*** Недостатки
**** C перемешан с Haskell
**** Странные хелперы на голом С
     в модуле hdbc-postgresql-helper.h находятся
     странные обертки, служащие для однократной
     финализации ресурса. Что мешало сделать это на
     Haskell не понятно.
**** Отладочные сообщения сделаны ужасно
     Следовало использовать условную компиляцию и флаг в
     cabal файле, чтобы код с отладочными сообщениями не
     компилировался без флага и компилировался бы с флагом.
**** Велосипеды с FFI вместо готовой postgresql-libpq
     Это воистину не постижимо, почему биндинг написан
     вручную вместо использования готового правиольно
     сделанного пакета.
*** Модули
**** HDBC.PostgreSQL.ConnectionImpl
***** Типы
****** Connection
       Инстанцирует IConnection.
**** HDBC.PostgreSQL.Connection
***** Недостатки 
      - Низкоуровневые обертки не вынесены в отдельный
        файл
      - Обертки возвращают опасные данные, должны быть
        обернуты в безопасные фунцкии.
      - frun, frunRaw финализируют Statement не внутри
        braket (при возникновении исключения оно не закроется)
***** Что делает
      - Создание соединения, с автокоммитом или без
      - Выполнение запросов
      - commit/rollback
      - интроспекция схемы
***** FFI
      - hdbc-postgresql-helper.c 
        Реализует какие то обертки с подсчетом ссылок, больше
        похоже на какой-то хак.
      - libpq
**** HDBC.PostgreSQL.Types
***** Conn
      type Conn = (ConnLock, ForeignPtr WrappedCConn)
***** ConnLock
      type ConnLock = MVar ()
**** HDBC.PostgreSQL.Statement
***** Что делает
      - Создание Statement
***** Типы
****** SState
       - Выполняет роль состояния Statement.
       - Не создает prepared statement при
         создании. Запрос интерпретируется каждый раз заново.
***** Недостатки
      - Содержит небезопасные биндинги
      - Выбрасывает ошибку вместо того чтобы возвращать Either
      - Кривое преобразование строк в даты.
***** Биндинги
      - libpq
      - hdbc-postgresql-helper.c
**** HDBC.PostgreSQL.PTypeConv
     - Преобразует postgresql типы в SqlTypeId
**** HDBC.PostgreSQL.Parser
     - Преобразование строки с запросом из вида ?, ? в
       вид $1, $2. Учитываются строковые литералы и
       коментарии, но наличие в строке констант вида $1
       не предусмотрено.
**** HDBC.PostgreSQL.ErrorCodes
     - Набор строковых констант
***** Странно
      Модуль экспортируется, но не используется нигде
      внутри. Не понятно зачем нужны эти константы снаружи.
**** HDBC.PostgreSQL.Utils
     - withConn, withConnLocked и подобные сервисные функции
** HDBC
*** Устаревшее
**** Используется ручные инстансы Typeable вместо дерайвинга
     Везде имена типов вбиты вручную
*** Недостатки
**** Неопределенность с освобождением Statement
     Каждый Statement может быть освобожден в любое время, ибо
     предлагается получать список результатов запроса с
     помощью fetchAllRows, который выполняет ленивое
     IO. Statement удалится только после того, как список
     будет прочитан полностью. А если прочитан не будет, то
     только после сборки мусора, которая может подоспеть,
     когда таких Statement наберется огромное количество, что
     вызовет исключение на стороне клиентской библиотеки
     (превышиние предельного количества открытых Statement).
**** Слабое тестирование
***** SqlValue плохо протестирована на преобразования данных
**** Берет на себя функции интроспецкии
     - Note taken on [2013-03-10 Вс. 03:40] \\
       Возможно описание стркутуры результата запроса тоже не нужно. Достаточно лишь
       возвращать данные в виде [SqlValue], и возможно количество столбцов в каждом
       кортеже результата.
     - Note taken on [2013-03-10 Вс. 03:31] \\
       Для выполнения запросов нужен тип SqlColDesc, для
       определения структуры результата запроса. Возможно
       интроспекция таблиц не является лишней, если этот тип
       все равно придется поддерживать в HDBC.
     Нет смысла реализовывать в HDBC интроспекции таблиц базы
     данных. Для выполнения запросов этого не нужно, а для
     полноценной абстрактной работы со схемой этого не
     достаточно. Всю работу со схемой базы логично вынести в
     отдельный модуль, который будет полноценно подддерживать
     интроспекцию таблиц (не только список колонок и их типы, но и
     констрейны, индексы, счетчики и прочее.
**** Работает с голыми Strings, не очень быстро, как правило
     Можно было бы использовать Text, или сразу
     ByteString для текста запросов. Серьезная экономия
     по памяти при большом количестве запросов
     гарантирована.

**** Поощряет использование леного fetchRow
     Вместо него нужно использовать ResourceT и Conduit
*** Хорошее
**** Statement всегда завершается ДО Connection
     Каждое соединение хранит список слабых ссылок на
     Statement, принадлежащие соединению. Это позволяет,
     с одной стороны, не беспокоится о том, что сборщик
     мусора сможет собрать Statement (ведь ссылки
     слабые), с другой, гарантированно закрыть все не
     завершенные запросы перед закрытием соединения.
**** SqlValue 
     Удачное решение для сериализации/десериализации
     данных из/в хаскель. Работа с базой данных по
     природе динамичная и, по этому, не логично ожидать,
     что в таблицах БД будут данные строго определенного
     типа. Гораздо удобнее определить набор правил по
     преобразованию различных типов данных, которые
     могут храниться в БД в тип Haskell и наоборот.
*** Модули
**** HDBC.ColTypes
***** Типы данных
****** SqlColDesc
******* Описание типы столбца таблицы
******* Используется в
        - IConnection как результат describeTable
****** SqlTypeId
******* Перечисление типов столбцов
******* Используется в SqlColDesc
****** SqlInternal
******* Перечисление диапазонов времени
**** HDBC.SqlValue
***** Типы данных
****** SqlValue
******* Используется для 
        сохранения данных в базу и вытаскивание данных из
        базы. На прямую с этим типом не работуют. Для
        преобразования из/в SqlValue написано много
        инстансов Convertible. От него зависит какие типы
        данных можно сохранять в базе данных и получать из
        нее.
******* Недостатки
        - Не содержит тип Decimal, вместо него содежит Rational,
          который плохо подходит для хранения чисел с
          произвольной точностью, ибо ни одна база данных не
          имеет встроенной поддержки Rational. Decimal
          является полным отражением типа DECIMAL/NUMERIC,
          который имеется в различных РСУБД
        - Большая путаница с датами, тип содежит конструкторы
          для разных типов, представляющих одно и то-же. Так
          как задача SqlValue состоит в том, чтобы хранить
          значение, которое может быть сохранено в базе, то не
          логично иметь несколько конструкторов для хранения
          одних и тех же данных
        - Инстансы Convertible содержат не логичные конверсии
          между числами и датами, опирающиеся на внутреннюю
          структуру типов Haskell. Такие конверсии должны
          фейлится по умолчанию, так как пользователь должен
          явно использовать тот или иной способ преобразования
          дат в числа и на оборот. Это нужно воизбежание
          сложных ошибок, которые можно обнаружить только во
          время испольнения
******* Используется в
        - IConnection в методе run
        - Statement в действиях execute
**** HDBC.DriverUtils
***** Функции
****** closeAllChildren, addChild, childFinalizer
******* Финализация и фильтрация списка слабых ссылок
******* Заметки
        - Фунция childFinalizer не блокирует MVar во время
          чистки списка от пустых ссылок. Вполне вероятна
          модификация MVar в цроцессе очистки списка ссылок.
***** Типы данных
****** ChildList
******* Используется для
        Хранение списка слабых ссылок на Statement.
**** HDBC.Locale
***** Функции
****** iso8601DateFormat
******* Создает строку с форматом даты
**** HDBC.Statement
***** Типы
****** Statement
       Интерфейс для работы с подготовленным выражением базы
       данных. Его возвращает соединение при выполнении
       prepare
******* Используется в
        - IConnection метод prepare возвращает 
****** SqlError
******* Ошибка исполнения запроса
******* Нет инстанса Exception, вернее инстанс пустой
**** HDBC.Types
***** Тайпклассы
****** IConnection
       Интерфейс к подключению к базе данных. Драйверы
       различных БД должны инстанцировать его для своих типов
***** Типы
****** ConnWrapper
       Работает как обертка для IConnection инстансов.
**** HDBC.Utils
***** Функции
****** Обработка ошибок
       - catchSql
       - handleSql
       - sqlExceptions
       - handleSqlError
         Преобразует SqlError в строку и поднимает
****** Обработка запросов
       - withTransaction
       - fetchAllRows
         лениво зачитывает список результатов с помощью
         unsafeInterleaveIO. Не безопасна
       - evalAll 
         форсирует вычисление списка результатов.
***** Недостатки
      - Много странных функций, дублирующих код, очень похожих
        на устаревший код, оставленный во имя
        совместимости. Например 
        
* Должно быть
** HDBC
*** Решаемые задачи
**** Что решает HDBC
***** Выполнение запросов
***** Отображение данных из Haskell в БД и обратоно
***** Общий интерфейс с гарантированной возможностью сохранения данных
      Каждый тип данных в SqlValue гарантированно
      сохраняется в ButeString в кодировке UTF-8 и
      читается обратно из строки. Это необходимо для
      того, чтобы каждый драйвер не реализовывал
      тривиальную сериализацию сам.
***** Гарантия того, что работа со Statement не возможна после закрытия Connection
      Это важно для безопасного использования интерфейса
      к БД. Подобные события могут вызывать исключния,
      но не сегфолты.
**** Что HDBC не делает
***** Интроспекция схемы базы данных
      Любая интроспекция схемы, в том числе просто
      список таблиц не является задачей HDBC. Данную
      задачу должен решать отдельный пакет более
      полноценно. Так же, как HDBC предоставляет общий
      интерфейс для выполнения запросов HDBC-Introspect
      (или другое название) должен предоставлять
      интерфейс для интроспекции схемы базы
      данных. Включая:
      1. Список таблиц
      2. Описание полей каждой таблицы
      3. Описание констрейнов каждой таблицы
      4. Список индесков
      5. Описание каждого индекса
      Каждый драйвер будет реализовывать эти методы для
      каждой базы данных, используя общий интерфейс HDBC
      либо низкоуровневый, специфичный для конкретной БД
      интерфейс.
***** Изменение схемы базы данных
      Этим HDBC тоже не занимается. Это должен
      реализовывать полноценный отдельный пакет
      (например HDBC-Schema, названия пока не
      определены), делающий это полноценно и
      правильно. Использовать должен типы из пакеты
      определенного выше (HDBC-Introspect), чтобы
      записанная схема совпадала с прочитанной. То есть
      пакет выполняет симметричную задачу, не
      интроспекцию, а изменение схемы.
***** Миграции
      Миграции должны выполняться отдельным пакетом,
      использующим HDBC-Schema и HDBC-Introspect. Это
      выглядит вполне логично, так как, методы изменения
      и интроспецкии схемы вынесены за общий интерфейс,
      миграция должна быть уже независимой от конкретной
      РСУБД.
***** Ленивое IO
      HDBC не занимается ленивым вытаскиванием данных из
      базы, для этого есть conduit, который сделан более
      безопасно, чем это есть в старом HDBC. И вообще,
      это не идиоматично для хаскеля.
***** Финализаторы 
      Если ссылка на Statement или Connection утеряна во
      время работы, это не является проблемой HDBC. Для
      этого есть bracket/ResourceT.
*** SqlValue
**** Решаемые задачи
***** Что делает SqlValue
****** Промежуточное представление данных
       SqlValue должен обертывать те типы, которые
       могут быть сохранены, либо получены от БД. 
****** Однозначные и рутинные преобразования данных
       Например, при получении из базы данных строки с
       сериализованным числом, мы можем
       расчитывать, что строка будет прочитана с число
       при попытке конвертации SqlValue в Integer.
***** Что не делает SqlValue
****** Хранение всех возможных вариантов данных
       Примером может служить timestamp из
       PostgreSql. На самом деле на стороне базы данных
       этот тип хранится в UTCTime, то есть, таймзона не
       сохраняется на стороне БД, вместо этого каждый
       раз при селекте timestamp переводится в локальную
       ДЛЯ СЕРВЕРА таймзону, либо, указанную в запросе
       (если таковая указана). Создавать отдельный
       конструктор в SqlValue для хранения даты/времени
       с таймзоной просто нет - таймзона все равно
       потеряется. Делать выборку с конвертацией UTCTime
       в конкретную таймзону тоже нет - это логичнее
       делать на стороне клиента с помощью библиотеки
       time. Таким образом SqlValue не содержит
       конструктора для хранения Timestamp, но содержит
       UTCTime.
****** Хранение данных, которые не хранятся в базе в нативных типах
       Пример из старой версии HDBC - SqlRational. Ни
       одна из РСУБД не может хранить рациональные числа
       во встроенных типах. Decimal, но никак не
       Rational. Если мы попытаемся сохранить Rational
       через SqlValue, драйверу ничего не остается,
       кроме как сериализовать данные в строку, а это
       можно сделать и так
       SqlString $ show $ rationalNumber
       Не нужно засорять ненужными конструкторами
       SqlValue
****** Странные и неоднозначные преобразования данных
       Попытка преобразоывать Integer в дату, или время,
       или GUID в число должны выбрасывать
       исключение. Неявные, неоднозначные и странные
       преобразования данных - это не то, на что я
       расчитываю, когда работаю с базой данных. Если я
       где-то ошибся, и пытаюсь прочитать число, а в
       базе данных на самом деле лежит дата, то я хочу
       об этом узнать, не нужно делать странное
       нелогичное преобразование даты в число, это не
       будет для меня полезным.
       
*** Бэкэнды
**** Как должны быть сделаны
***** Использование готовых полноценных биндингов
      Для всех баз данных есть прекрасные готовые
      биндинги. Только бери и пользуйся, никаких тебе
      биндингов к C и никаких сегфолтов. Все уже
      написано и протестировано, почему нет ?
**** Какие драйверы будут переписаны
***** PostgreSql
***** Sqlite3
***** Mysql
      На самом деле такого драйвера и не было. Был
      только драйвер ODBC.
**** ODBC не нужен
     Скорее всего, этот драйвер не будет мной добавлен,
     ибо для всех баз данных есть готовые биндинги на
     которых не долго сделать драйвер для HDBC, и это
     будет более полноценное решение, ибо ODBC убог, не
     поддерживает даже UTCTime.
