

* hdbc-sqlite3

** Модули
*** HDBC.Sqlite3.Connection
**** Что делает
     - Создает соединение
     - Интроспекция таблиц
     - commit/rollback
* hdbc-postgresql
** Недостатки
*** C перемешан с Haskell
*** Странные хелперы на голом С
    в модуле hdbc-postgresql-helper.h находятся
    странные обертки, служащие для однократной
    финализации ресурса. Что мешало сделать это на
    Haskell не понятно.
** Модули
*** HDBC.PostgreSQL.ConnectionImpl
**** Типы
***** Connection
      Инстанцирует IConnection.
*** HDBC.PostgreSQL.Connection
**** Недостатки 
     - Низкоуровневые обертки не вынесены в отдельный
       файл
     - Обертки возвращают опасные данные, должны быть
       обернуты в безопасные фунцкии.
     - frun, frunRaw финализируют Statement не внутри
       braket (при возникновении исключения оно не закроется)
**** Что делает
     - Создание соединения, с автокоммитом или без
     - Выполнение запросов
     - commit/rollback
     - интроспекция схемы
**** FFI
     - hdbc-postgresql-helper.c 
       Реализует какие то обертки с подсчетом ссылок, больше
       похоже на какой-то хак.
     - libpq
*** HDBC.PostgreSQL.Types
**** Conn
     type Conn = (ConnLock, ForeignPtr WrappedCConn)
**** ConnLock
     type ConnLock = MVar ()
*** HDBC.PostgreSQL.Statement
**** Что делает
     - Создание Statement
**** Типы
***** SState
      - Выполняет роль состояния Statement.
      - Не создает prepared statement при
        создании. Запрос интерпретируется каждый раз заново.
**** Недостатки
     - Содержит небезопасные биндинги
     - Выбрасывает ошибку вместо того чтобы возвращать Either
     - Кривое преобразование строк в даты.
**** Биндинги
     - libpq
     - hdbc-postgresql-helper.c
*** HDBC.PostgreSQL.PTypeConv
    - Преобразует postgresql типы в SqlTypeId
*** HDBC.PostgreSQL.Parser
    - Преобразование строки с запросом из вида ?, ? в
      вид $1, $2. Учитываются строковые литералы и
      коментарии, но наличие в строке констант вида $1
      не предусмотрено.
*** HDBC.PostgreSQL.ErrorCodes
    - Набор строковых констант
**** Странно
     Модуль экспортируется, но не используется нигде
     внутри. Не понятно зачем нужны эти константы снаружи.
*** HDBC.PostgreSQL.Utils
    - withConn, withConnLocked и подобные сервисные функции
* HDBC
** Устаревшее
*** Используется ручные инстансы Typeable вместо дерайвинга
    Везде имена типов вбиты вручную
** Недостатки
*** Неопределенность с освобождением Statement
    Каждый Statement может быть освобожден в любое время, ибо
    предлагается получать список результатов запроса с
    помощью fetchAllRows, который выполняет ленивое
    IO. Statement удалится только после того, как список
    будет прочитан полностью. А если прочитан не будет, то
    только после сборки мусора, которая может подоспеть,
    когда таких Statement наберется огромное количество, что
    вызовет исключение на стороне клиентской библиотеки
    (превышиние предельного количества открытых Statement).
*** Слабое тестирование
**** SqlValue плохо протестирована на преобразования данных
*** Берет на себя функции интроспецкии
    - Note taken on [2013-03-10 Вс. 03:40] \\
      Возможно описание стркутуры результата запроса тоже не нужно. Достаточно лишь
      возвращать данные в виде [SqlValue], и возможно количество столбцов в каждом
      кортеже результата.
    - Note taken on [2013-03-10 Вс. 03:31] \\
      Для выполнения запросов нужен тип SqlColDesc, для
      определения структуры результата запроса. Возможно
      интроспекция таблиц не является лишней, если этот тип
      все равно придется поддерживать в HDBC.
    Нет смысла реализовывать в HDBC интроспекции таблиц базы
    данных. Для выполнения запросов этого не нужно, а для
    полноценной абстрактной работы со схемой этого не
    достаточно. Всю работу со схемой базы логично вынести в
    отдельный модуль, который будет полноценно подддерживать
    интроспекцию таблиц (не только список колонок и их типы, но и
    констрейны, индексы, счетчики и прочее.
** Хорошее
*** Statement всегда завершается ДО Connection
    Каждое соединение хранит список слабых ссылок на
    Statement, принадлежащие соединению. Это позволяет,
    с одной стороны, не беспокоится о том, что сборщик
    мусора сможет собрать Statement (ведь ссылки
    слабые), с другой, гарантированно закрыть все не
    завершенные запросы перед закрытием соединения.
*** SqlValue 
    Удачное решение для сериализации/десериализации
    данных из/в хаскель. Работа с базой данных по
    природе динамичная и, по этому, не логично ожидать,
    что в таблицах БД будут данные строго определенного
    типа. Гораздо удобнее определить набор правил по
    преобразованию различных типов данных, которые
    могут храниться в БД в тип Haskell и наоборот.
** Модули
*** HDBC.ColTypes
**** Типы данных
***** SqlColDesc
****** Описание типы столбца таблицы
****** Используется в
       - IConnection как результат describeTable
***** SqlTypeId
****** Перечисление типов столбцов
****** Используется в SqlColDesc
***** SqlInternal
****** Перечисление диапазонов времени
*** HDBC.SqlValue
**** Типы данных
***** SqlValue
****** Используется для 
       сохранения данных в базу и вытаскивание данных из
       базы. На прямую с этим типом не работуют. Для
       преобразования из/в SqlValue написано много
       инстансов Convertible. От него зависит какие типы
       данных можно сохранять в базе данных и получать из
       нее.
****** Недостатки
       - Не содержит тип Decimal, вместо него содежит Rational,
         который плохо подходит для хранения чисел с
         произвольной точностью, ибо ни одна база данных не
         имеет встроенной поддержки Rational. Decimal
         является полным отражением типа DECIMAL/NUMERIC,
         который имеется в различных РСУБД
       - Большая путаница с датами, тип содежит конструкторы
         для разных типов, представляющих одно и то-же. Так
         как задача SqlValue состоит в том, чтобы хранить
         значение, которое может быть сохранено в базе, то не
         логично иметь несколько конструкторов для хранения
         одних и тех же данных
       - Инстансы Convertible содержат не логичные конверсии
         между числами и датами, опирающиеся на внутреннюю
         структуру типов Haskell. Такие конверсии должны
         фейлится по умолчанию, так как пользователь должен
         явно использовать тот или иной способ преобразования
         дат в числа и на оборот. Это нужно воизбежание
         сложных ошибок, которые можно обнаружить только во
         время испольнения
****** Используется в
       - IConnection в методе run
       - Statement в действиях execute
*** HDBC.DriverUtils
**** Функции
***** closeAllChildren, addChild, childFinalizer
****** Финализация и фильтрация списка слабых ссылок
****** Заметки
       - Фунция childFinalizer не блокирует MVar во время
         чистки списка от пустых ссылок. Вполне вероятна
         модификация MVar в цроцессе очистки списка ссылок.
**** Типы данных
***** ChildList
****** Используется для
       Хранение списка слабых ссылок на Statement.
*** HDBC.Locale
**** Функции
***** iso8601DateFormat
****** Создает строку с форматом даты
*** HDBC.Statement
**** Типы
***** Statement
      Интерфейс для работы с подготовленным выражением базы
      данных. Его возвращает соединение при выполнении
      prepare
****** Используется в
       - IConnection метод prepare возвращает 
***** SqlError
****** Ошибка исполнения запроса
****** Нет инстанса Exception, вернее инстанс пустой
*** HDBC.Types
**** Тайпклассы
***** IConnection
      Интерфейс к подключению к базе данных. Драйверы
      различных БД должны инстанцировать его для своих типов
**** Типы
***** ConnWrapper
      Работает как обертка для IConnection инстансов.
*** HDBC.Utils
**** Функции
***** Обработка ошибок
      - catchSql
      - handleSql
      - sqlExceptions
      - handleSqlError
        Преобразует SqlError в строку и поднимает
***** Обработка запросов
      - withTransaction
      - fetchAllRows
        лениво зачитывает список результатов с помощью
        unsafeInterleaveIO. Не безопасна
      - evalAll 
        форсирует вычисление списка результатов.
**** Недостатки
     - Много странных функций, дублирующих код, очень похожих
       на устаревший код, оставленный во имя
       совместимости. Например 
